2024-11-14 08:12:36,571 INFO ipython === bench console session ===
2024-11-14 08:12:36,572 INFO ipython def update_job_offer_states():
    # Obtener todas las ofertas de trabajo con docstatus = 1 y workflow_state = "Validado"
    job_offers = frappe.get_all("Job Offer", filters={"docstatus": 1, "workflow_state": "Validado"}, fields=["name", "custom_fecha_fin"])

    for job in job_offers:
        doc = frappe.get_doc("Job Offer", job.name)

        # Modificar temporalmente los campos obligatorios
        mandatory_fields = [df for df in doc.meta.fields if df.reqd]
        for df in mandatory_fields:
            df.reqd = 0  # Desmarcar como obligatorio

        # Truncar cualquier campo que exceda la longitud máxima
        for field in doc.meta.fields:
            if field.fieldtype in ["Data", "Text", "Small Text", "Long Text", "Code", "HTML"] and field.length:
                value = doc.get(field.fieldname)
                if value and len(value) > field.length:
                    doc.set(field.fieldname, value[:field.length])

        # Definir la acción basada en custom_fecha_fin
        accion = "Validado a Alta" if str(doc.custom_fecha_fin) >= frappe.utils.nowdate() else "Solicitar Baja"

        # Obtener transiciones válidas para verificar si la acción es posible
        from frappe.model.workflow import get_transitions, WorkflowTransitionError
        transiciones = [t.action for t in get_transitions(doc)]

        # Validar si la acción está en las transiciones posibles
        if accion in transiciones:
            try:
                frappe.model.workflow.apply_workflow(frappe.as_json(doc), accion)

                # Recargar y guardar el documento con ignore_version para evitar errores de timestamp
                doc.reload()  # Recargar antes de guardar
                doc.save(ignore_version=True)

                # Imprimir el documento modificado
                print(f"Documento {doc.name} modificado con estado '{accion}'")

            except frappe.PermissionError:
                frappe.log_error(f"No se pudo aplicar '{accion}' en {doc.name} debido a permisos insuficientes.")
            except WorkflowTransitionError as e:
                frappe.log_error(f"Error de transición: {str(e)} en {doc.name} para '{accion}'")
            except Exception as e:
                if "TimestampMismatchError" in str(e):
                    doc.reload()  # Recargar en caso de conflicto de timestamp
                    doc.save(ignore_version=True)
                    print(f"Documento {doc.name} modificado con estado '{accion}' tras recargar por conflicto de timestamp")
                else:
                    frappe.log_error(f"Error inesperado al guardar {doc.name}: {str(e)}")

        # Restaurar los campos obligatorios
        for df in mandatory_fields:
            df.reqd = 1  # Restaurar como obligatorio

    frappe.msgprint("Estados de las ofertas de trabajo actualizados según 'custom_fecha_fin'.")
update_job_offer_states()
2024-11-14 08:12:36,572 INFO ipython === session end ===
2024-11-14 10:13:52,443 INFO ipython === bench console session ===
2024-11-14 10:13:52,443 INFO ipython import frappe



def update_invalid_records():
    # Define los valores por defecto y opciones válidas
    default_tipo = "Contrato"  # Puedes cambiarlo según prefieras
    default_designation = "Aux. Admín."
    lista_tipos = {"Contrato", "Llamamiento"}



    # Filtra y obtiene los registros de 'Job Offer' con docstatus=1 y workflow_state='Validado'
    job_offers = frappe.get_all("Job Offer", 
                                filters={"docstatus": 1, "workflow_state": "Validado"}, 
                                fields=["name", "custom_tipo_de_hoja_de_contratacion", "designation", "custom_fecha_fin"])



    # Recorre cada registro
    for job_offer in job_offers:
        tipo = job_offer.get('custom_tipo_de_hoja_de_contratacion')
        puesto = job_offer.get('designation')

        # Verifica si los campos son inválidos y necesita actualizarse
        needs_update = False

        # Validación de `custom_tipo_de_hoja_de_contratacion`
        if not tipo or tipo not in lista_tipos:
            job_offer['custom_tipo_de_hoja_de_contratacion'] = default_tipo
            needs_update = True



        # Validación de `designation`
        if not puesto or not frappe.db.exists('Designation', puesto):
            job_offer['designation'] = default_designation
            needs_update = True



        # Si necesita actualización, guarda el cambio en la base de datos
        if needs_update:
            try:
                # Carga el documento para actualizar
                doc = frappe.get_doc("Job Offer", job_offer["name"])
                doc.custom_tipo_de_hoja_de_contratacion = job_offer['custom_tipo_de_hoja_de_contratacion']
                doc.designation = job_offer['designation']
                doc.save()
                frappe.db.commit()  # Confirma los cambios en la base de datos
                print(f"Registro actualizado: {job_offer['name']}")
            except Exception as e:
                print(f"Error al actualizar el registro {job_offer['name']}: {e}")
                frappe.db.rollback()  # Revierte en caso de error



# Ejecuta la función
update_invalid_records()
2024-11-14 10:13:52,444 INFO ipython import frappe



def update_invalid_records():
    default_tipo = "Contrato"  # Puedes cambiarlo según prefieras
    default_designation = "Aux. Admín."
    lista_tipos = {"Contrato", "Llamamiento"}



    # Filtra y obtiene los registros de 'Job Offer' con docstatus=1 y workflow_state='Validado'
    job_offers = frappe.get_all("Job Offer", 
                                filters={"docstatus": 1, "workflow_state": "Validado"}, 
                                fields=["name", "custom_tipo_de_hoja_de_contratacion", "designation", "custom_fecha_fin"])



    # Recorre cada registro
    for job_offer in job_offers:
        tipo = job_offer.get('custom_tipo_de_hoja_de_contratacion')
        puesto = job_offer.get('designation')

        # Verifica si los campos son inválidos y necesita actualizarse
        needs_update = False

        # Validación de `custom_tipo_de_hoja_de_contratacion`
        if not tipo or tipo not in lista_tipos:
            job_offer['custom_tipo_de_hoja_de_contratacion'] = default_tipo
            needs_update = True



        # Validación de `designation`
        if not puesto or not frappe.db.exists('Designation', puesto):
            job_offer['designation'] = default_designation
            needs_update = True



        # Si necesita actualización, guarda el cambio en la base de datos
        if needs_update:
            try:
                # Carga el documento para actualizar
                doc = frappe.get_doc("Job Offer", job_offer["name"])
                doc.custom_tipo_de_hoja_de_contratacion = job_offer['custom_tipo_de_hoja_de_contratacion']
                doc.designation = job_offer['designation']
                doc.save()
                frappe.db.commit()  # Confirma los cambios en la base de datos
                print(f"Registro actualizado: {job_offer['name']}")
            except Exception as e:
                print(f"Error al actualizar el registro {job_offer['name']}: {e}")
                frappe.db.rollback()  # Revierte en caso de error



# Ejecuta la función
update_invalid_records()
2024-11-14 10:13:52,444 INFO ipython import frappe

def update_invalid_records():
    # Define los valores por defecto y opciones válidas
    default_tipo = "Contrato"  # Puedes cambiarlo según prefieras
    default_designation = "Aux. Admin." 
    lista_tipos = {"Contrato", "Llamamiento"}

    # Filtra y obtiene los registros de 'Job Offer' con docstatus=1 y workflow_state='Validado'
    job_offers = frappe.get_all("Job Offer", 
                                filters={"docstatus": 1, "workflow_state": "Validado"}, 
                                fields=["name", "custom_tipo_de_hoja_de_contratacion", "designation", "custom_fecha_fin"])

    # Recorre cada registro
    for job_offer in job_offers:
        tipo = job_offer.get('custom_tipo_de_hoja_de_contratacion')
        puesto = job_offer.get('designation')
        
        # Verifica si los campos son inválidos y necesita actualizarse
        needs_update = False
        
        # Validación de `custom_tipo_de_hoja_de_contratacion`
        if not tipo or tipo not in lista_tipos:
            job_offer['custom_tipo_de_hoja_de_contratacion'] = default_tipo
            needs_update = True

        # Validación de `designation`
        if not puesto or not frappe.db.exists('Designation', puesto):
            job_offer['designation'] = default_designation
            needs_update = True

        # Si necesita actualización, guarda el cambio en la base de datos
        if needs_update:
            try:
                # Carga el documento para actualizar
                doc = frappe.get_doc("Job Offer", job_offer["name"])
                doc.custom_tipo_de_hoja_de_contratacion = job_offer['custom_tipo_de_hoja_de_contratacion']
                doc.designation = job_offer['designation']
                doc.save()
                frappe.db.commit()  # Confirma los cambios en la base de datos
                print(f"Registro actualizado: {job_offer['name']}")
            except Exception as e:
                print(f"Error al actualizar el registro {job_offer['name']}: {e}")
                frappe.db.rollback()  # Revierte en caso de error

# Ejecuta la función
update_invalid_records()
2024-11-14 10:13:52,444 INFO ipython izar el registro HR-OFF-2024-06664:  Not allowed to change Puesto after submission from Profesor/a Titular to Aux. Admín.
Error al actualizar el registro HR-OFF-2024-06665:  Not allowed to change Puesto after submission from Profesor/a Titular to Aux. Admín.
Error al actualizar el registro HR-OFF-2024-06666:  Not allowed to change Puesto after submission from Profesor/a Titular to Aux. Admín.
Error al actualizar el registro HR-OFF-2024-06667:  Not allowed to change Puesto after submission from Profesor/a Titular to Aux. Admín.
Error al actualizar el registro HR-OFF-2024-06668:  Not allowed to change Puesto after submission from Profesor/a Titular to Aux. Admín.
2024-11-14 10:13:52,444 INFO ipython import frappe

def update_invalid_records():
    # Define los valores por defecto y opciones válidas
    default_tipo = "Contrato"  # Puedes cambiarlo según prefieras
    default_designation = "Aux. Admin." 
    lista_tipos = {"Contrato", "Llamamiento"}

    # Filtra y obtiene los registros de 'Job Offer' con docstatus=1 y workflow_state='Validado'
    job_offers = frappe.get_all("Job Offer", 
                                filters={"docstatus": 1, "workflow_state": "Validado"}, 
                                fields=["name", "custom_tipo_de_hoja_de_contratacion", "designation", "custom_fecha_fin"])

    # Recorre cada registro
    for job_offer in job_offers:
        tipo = job_offer.get('custom_tipo_de_hoja_de_contratacion')
        puesto = job_offer.get('designation')
        
        # Verifica si los campos son inválidos y necesita actualizarse
        needs_update = False
        
        # Validación de `custom_tipo_de_hoja_de_contratacion`
        if not tipo or tipo not in lista_tipos:
            job_offer['custom_tipo_de_hoja_de_contratacion'] = default_tipo
            needs_update = True

        # Validación de `designation`
        if not puesto or not frappe.db.exists('Designation', puesto):
            job_offer['designation'] = default_designation
            needs_update = True

        # Si necesita actualización, guarda el cambio en la base de datos
        if needs_update:
            try:
                # Carga el documento para actualizar
                doc = frappe.get_doc("Job Offer", job_offer["name"])
                doc.custom_tipo_de_hoja_de_contratacion = job_offer['custom_tipo_de_hoja_de_contratacion']
                doc.designation = job_offer['designation']
                doc.save()
                frappe.db.commit()  # Confirma los cambios en la base de datos
                print(f"Registro actualizado: {job_offer['name']}")
            except Exception as e:
                print(f"Error al actualizar el registro {job_offer['name']}: {e}")
                frappe.db.rollback()  # Revierte en caso de error

# Ejecuta la función
update_invalid_records()
2024-11-14 10:13:52,444 INFO ipython import frappe

def update_invalid_records():
    # Define los valores por defecto y opciones válidas
    default_tipo = "Contrato"  # Puedes cambiarlo según prefieras
    default_designation = "Aux. Admin." 
    lista_tipos = {"Contrato", "Llamamiento"}

    # Filtra y obtiene los registros de 'Job Offer' con docstatus=1 y workflow_state='Validado'
    job_offers = frappe.get_all("Job Offer", 
                                filters={"docstatus": 1, "workflow_state": "Validado"}, 
                                fields=["name", "custom_tipo_de_hoja_de_contratacion", "designation", "custom_fecha_fin"])

    # Recorre cada registro
    for job_offer in job_offers:
        tipo = job_offer.get('custom_tipo_de_hoja_de_contratacion')
        puesto = job_offer.get('designation')
        
        # Verifica si los campos son inválidos y necesita actualizarse
        needs_update = False
        
        # Validación de `custom_tipo_de_hoja_de_contratacion`
        if not tipo or tipo not in lista_tipos:
            frappe.db.set_value("Job Offer", job_offer["name"], "custom_tipo_de_hoja_de_contratacion", default_tipo)
            needs_update = True

        # Validación de `designation`
        if not puesto or not frappe.db.exists('Designation', puesto):
            frappe.db.set_value("Job Offer", job_offer["name"], "designation", default_designation)
            needs_update = True

        # Confirma en la base de datos si hubo una actualización
        if needs_update:
            try:
                frappe.db.commit()  # Confirma los cambios en la base de datos
                print(f"Registro actualizado: {job_offer['name']}")
            except Exception as e:
                print(f"Error al actualizar el registro {job_offer['name']}: {e}")
                frappe.db.rollback()  # Revierte en caso de error

# Ejecuta la función
update_invalid_records()
2024-11-14 10:13:52,444 INFO ipython === session end ===
2024-11-14 11:21:38,707 INFO ipython === bench console session ===
2024-11-14 11:21:38,708 INFO ipython === session end ===
2024-11-14 12:04:20,384 INFO ipython === bench console session ===
2024-11-14 12:04:20,385 INFO ipython import frappe
 
def delete_files_by_name():
    # Lista de nombres de archivo extraídos de los errores
    nombres_archivos = [
        "MediavillaCorralCarlosCurriculumVitae.pdf",
        "CV Beatriz FernÃ¡ndez.pdf",
        "curriculum vitae Dioni.pdf",
        "Currículum vitae Dalila_Hamdi.pdf",
        "NIE_DH.pdf",
        "CV Sara Sanz.pdf",
        "DNI_FERNANDEZ FUENTES, IRATXE.pdf",
        "CVMONTAÑA333225.pdf",
        "1.DNI MSB.pdf",
        "ARROYO, MARÍA JESÚS_DNI65fd4a.pdf",
        "Mariam_Martinez Tabernero_CV (3).PDF",
        "DNI MARIAN MARTINEZ TABERNERO.pdf",
        "CV Luis Olmo _2024.pdf",
        "DNIc2b97b.pdf",
        "cv FRANCISCO PÉREZ VERA 2024.pdf",
        "CURRÍCULUM NIEVES CAÑADAS GONZALEZ.pdf",
        "CV RAQUEL CUENCA_MODELO ATU_2023.pdf"
    ]
 
    # Recorre cada nombre de archivo
    for nombre_archivo in nombres_archivos:
        try:
            # Construye y ejecuta la consulta SQL para eliminar archivos específicos
            frappe.db.sql("""
                DELETE FROM `tabFile` 
                WHERE `attached_to_doctype` = 'Job Offer' 
                AND `file_url` LIKE %s
            """, (f"%{nombre_archivo}%",))
            frappe.db.commit()  # Confirma la eliminación en la base de datos
            print(f"Archivo eliminado: {nombre_archivo}")
        except Exception as e:
            print(f"Error al eliminar el archivo {nombre_archivo}: {e}")
            frappe.db.rollback()  # Revierte en caso de error
 
# Ejecuta la función
delete_files_by_name()
2024-11-14 12:04:20,385 INFO ipython === session end ===
2024-11-14 12:45:06,199 INFO ipython === bench console session ===
2024-11-14 12:45:06,201 INFO ipython 
import frappe
 
def add_zero_to_dni():
    # Lista de DNI/NIE extraídos de los errores
    dni_nie_list = [
        "7876634P",
        "9341295Y",
        "7858631Z",
        "Y8296141D",
        "9329858T",
        "9337249P",
        "3450244Z",
        "9312584E"
    ]
 
    for dni in dni_nie_list:
        # Verifica si el valor es un NIE (si empieza con una letra)
        if dni[0].isalpha():
            print(f"Saltando NIE: {dni}")
            continue
 
        # Añade un "0" al inicio del DNI
        new_dni = "0" + dni
 
        # Actualiza el registro correspondiente en la base de datos
        try:
            # Filtra el registro en la tabla `Employee` o la correspondiente
            frappe.db.sql("""
                UPDATE `tabEmployee` 
                SET `custom_dninie_id` = %s 
                WHERE `custom_dninie_id` = %s
            """, (new_dni, dni))
            frappe.db.commit()  # Confirma la actualización en la base de datos
            print(f"Actualizado {dni} a {new_dni}")
        except Exception as e:
            print(f"Error al actualizar {dni}: {e}")
            frappe.db.rollback()  # Revierte en caso de error
 
# Ejecuta la función
add_zero_to_dni()
2024-11-14 12:45:06,201 INFO ipython === session end ===
2024-11-14 13:17:34,374 INFO ipython === bench console session ===
2024-11-14 13:17:34,374 INFO ipython === session end ===
2024-11-16 03:22:15,863 INFO ipython === bench console session ===
2024-11-16 03:22:15,863 INFO ipython === session end ===
2024-11-21 10:23:43,712 INFO ipython === bench console session ===
2024-11-21 10:23:43,713 INFO ipython import frappe
import pandas as pd
from frappe.utils.file_manager import save_file

def export_expense_claim_summary():
    # Query para obtener los datos necesarios de Expense Claim
    expense_claims = frappe.db.get_all(
        'Expense Claim',
        fields=['employee', 'employee_name', 'custom_dninie_Id', 'company', 'expense_claim_type', 'total_claimed_amount'],
        filters={'docstatus': 1}  # Solo los documentos aprobados
    )

    if not expense_claims:
        frappe.throw("No se encontraron registros de Expense Claim aprobados.")

    # Convertir los resultados a un DataFrame de Pandas
    df = pd.DataFrame(expense_claims)

    # Reemplazar `custom_dninie_Id` con `name` si está vacío
    df['dni'] = df['custom_dninie_Id'].fillna(df['employee'])

    # Agrupar por empleado y tipo de gasto, sumando los totales
    grouped_df = df.groupby(['employee', 'employee_name', 'dni', 'company', 'expense_claim_type'], as_index=False).agg({
        'total_claimed_amount': 'sum'
    })

    # Pivotar los datos para tener una columna por cada tipo de gasto
    pivot_df = grouped_df.pivot(
        index=['employee', 'employee_name', 'dni', 'company'],
        columns='expense_claim_type',
        values='total_claimed_amount'
    ).reset_index()

    # Reemplazar NaN con 0 para las columnas de gastos
    pivot_df.fillna(0, inplace=True)

    # Crear el archivo Excel
    file_name = "Expense_Claim_Summary.xlsx"
    file_path = frappe.utils.get_site_path("public", "files", file_name)

    pivot_df.to_excel(file_path, index=False)

    # Guardar el archivo en el sistema de archivos de Frappe
    save_file(
        file_name,
        open(file_path, 'rb').read(),
        dt=None,
        dn=None,
        is_private=0
    )

    frappe.msgprint(f"Archivo generado correctamente: {file_path}")

# Llamar a la función
export_expense_claim_summary()
2024-11-21 10:23:43,713 INFO ipython === session end ===
2024-11-21 10:35:47,471 INFO ipython === bench console session ===
2024-11-21 10:35:47,471 INFO ipython import frappe
import pandas as pd
from frappe.utils.file_manager import save_file

def get_company_from_job_offer():
    """
    Mapea el DNI de los empleados con la empresa correspondiente,
    basado en el estado de contratación en Job Offer.
    """
    job_offers = frappe.db.sql("""
        SELECT
            jo.custom_dninie AS dni,
            jo.company,
            jo.status,
            jo.custom_fecha_fin
        FROM
            `tabJob Offer` jo
        WHERE
            jo.docstatus = 1
    """, as_dict=True)

    # Crear un mapeo DNI -> Empresa
    employee_company_map = {}
    job_offers_df = pd.DataFrame(job_offers)

    if not job_offers_df.empty:
        for dni, group in job_offers_df.groupby('dni'):
            group = group.sort_values(
                by=['status', 'custom_fecha_fin'], 
                ascending=[False, False]  # Alta primero, Baja con fecha más reciente
            )
            selected_row = group.iloc[0]
            employee_company_map[dni] = selected_row['company']

    return employee_company_map

def export_expense_claim_summary():
    # Obtener datos de Expense Claim
    expense_claims = frappe.db.get_all(
        'Expense Claim',
        fields=['employee', 'expense_claim_type', 'total_claimed_amount'],
        filters={'docstatus': 1}  # Solo documentos aprobados
    )

    if not expense_claims:
        frappe.throw("No se encontraron registros de Expense Claim aprobados.")

    # Obtener datos de los empleados
    employees = frappe.db.get_all(
        'Employee',
        fields=['name as employee', 'employee_name', 'custom_dninie_Id as dni']
    )

    # Convertir a DataFrames
    expense_claims_df = pd.DataFrame(expense_claims)
    employees_df = pd.DataFrame(employees)

    # Mapeo DNI -> Empresa desde Job Offer
    employee_company_map = get_company_from_job_offer()
    employees_df['company'] = employees_df['dni'].map(employee_company_map)

    # Unir datos de Expense Claim con detalles del empleado
    merged_df = expense_claims_df.merge(employees_df, on='employee', how='left')

    # Agrupar por empleado y tipo de gasto
    grouped_df = merged_df.groupby(['employee', 'employee_name', 'dni', 'company', 'expense_claim_type'], as_index=False).agg({
        'total_claimed_amount': 'sum'
    })

    # Pivotar los datos para que cada tipo de gasto sea una columna
    pivot_df = grouped_df.pivot(
        index=['employee', 'employee_name', 'dni', 'company'],
        columns='expense_claim_type',
        values='total_claimed_amount'
    ).reset_index()

    # Reemplazar NaN con 0 en las columnas de gastos
    pivot_df.fillna(0, inplace=True)

    # Crear el archivo Excel
    file_name = "Expense_Claim_Summary.xlsx"
    file_path = frappe.utils.get_site_path("public", "files", file_name)

    pivot_df.to_excel(file_path, index=False)

    # Guardar el archivo en el sistema de archivos de Frappe
    save_file(
        file_name,
        open(file_path, 'rb').read(),
        dt=None,
        dn=None,
        is_private=0
    )

    frappe.msgprint(f"Archivo generado correctamente: {file_path}")

# Llamar a la función
export_expense_claim_summary()
2024-11-21 10:35:47,471 INFO ipython === session end ===
2024-11-21 10:40:06,099 INFO ipython === bench console session ===
2024-11-21 10:40:06,100 INFO ipython import frappe
import pandas as pd
from frappe.utils.file_manager import save_file

def get_company_from_job_offer():
    """
    Mapea el DNI de los empleados con la empresa correspondiente,
    basado en el estado de contratación en Job Offer.
    """
    job_offers = frappe.db.sql("""
        SELECT
            jo.custom_dninie AS dni,
            jo.company,
            jo.status,
            jo.custom_fecha_fin
        FROM
            `tabJob Offer` jo
        WHERE
            jo.docstatus = 1
    """, as_dict=True)

    # Crear un mapeo DNI -> Empresa
    employee_company_map = {}
    job_offers_df = pd.DataFrame(job_offers)

    if not job_offers_df.empty:
        for dni, group in job_offers_df.groupby('dni'):
            group = group.sort_values(
                by=['status', 'custom_fecha_fin'], 
                ascending=[False, False]  # Alta primero, Baja con fecha más reciente
            )
            selected_row = group.iloc[0]
            employee_company_map[dni] = selected_row['company']

    return employee_company_map

def export_expense_claim_summary():
    # Obtener datos de Expense Claim y sus detalles desde Expense Claim Detail
    expense_claim_details = frappe.db.sql("""
        SELECT
            ec.employee,
            ec_detail.expense_type AS expense_claim_type,  -- Asegúrate de que este sea el nombre correcto del campo
            ec_detail.amount AS total_claimed_amount
        FROM
            `tabExpense Claim Detail` ec_detail
        INNER JOIN
            `tabExpense Claim` ec
        ON
            ec_detail.parent = ec.name
        WHERE
            ec.docstatus = 0
    """, as_dict=True)

    if not expense_claim_details:
        frappe.throw("No se encontraron registros de Expense Claim en borrador.")

    # Validar datos antes de convertir a DataFrame
    if not isinstance(expense_claim_details, list) or not all(isinstance(row, dict) for row in expense_claim_details):
        frappe.throw("Los datos de Expense Claim Detail no tienen el formato esperado.")

    # Convertir a DataFrame
    try:
        expense_claims_df = pd.DataFrame(expense_claim_details)
    except Exception as e:
        frappe.throw(f"Error al convertir los datos de Expense Claim a DataFrame: {str(e)}")

    # Obtener datos de los empleados
    employees = frappe.db.get_all(
        'Employee',
        fields=['name as employee', 'employee_name', 'custom_dninie_Id as dni']
    )

    # Convertir datos de empleados a DataFrame
    employees_df = pd.DataFrame(employees)

    # Mapeo DNI -> Empresa desde Job Offer
    employee_company_map = get_company_from_job_offer()
    employees_df['company'] = employees_df['dni'].map(employee_company_map)

    # Validar datos de empleados antes de unirlos
    if employees_df.empty:
        frappe.throw("No se encontraron registros de empleados.")

    # Unir datos de Expense Claim con detalles del empleado
    merged_df = expense_claims_df.merge(employees_df, on='employee', how='left')

    # Agrupar por empleado y tipo de gasto
    grouped_df = merged_df.groupby(['employee', 'employee_name', 'dni', 'company', 'expense_claim_type'], as_index=False).agg({
        'total_claimed_amount': 'sum'
    })

    # Pivotar los datos para que cada tipo de gasto sea una columna
    pivot_df = grouped_df.pivot(
        index=['employee', 'employee_name', 'dni', 'company'],
        columns='expense_claim_type',
        values='total_claimed_amount'
    ).reset_index()

    # Reemplazar NaN con 0 en las columnas de gastos
    pivot_df.fillna(0, inplace=True)

    # Crear el archivo Excel
    file_name = "Expense_Claim_Summary.xlsx"
    file_path = frappe.utils.get_site_path("public", "files", file_name)

    try:
        pivot_df.to_excel(file_path, index=False)
    except Exception as e:
        frappe.throw(f"Error al generar el archivo Excel: {str(e)}")

    # Guardar el archivo en el sistema de archivos de Frappe
    save_file(
        file_name,
        open(file_path, 'rb').read(),
        dt=None,
        dn=None,
        is_private=0
    )

    frappe.msgprint(f"Archivo generado correctamente: {file_path}")

# Llamar a la función
export_expense_claim_summary()
2024-11-21 10:40:06,102 INFO ipython === session end ===
2024-11-21 10:44:49,300 INFO ipython === bench console session ===
2024-11-21 10:44:49,300 INFO ipython import frappe
import pandas as pd
from frappe.utils.file_manager import save_file

def get_company_from_job_offer():
    """
    Mapea el DNI de los empleados con la empresa correspondiente,
    basado en el estado de contratación en Job Offer.
    """
    job_offers = frappe.db.sql("""
        SELECT
            jo.custom_dninie AS dni,
            jo.company,
            jo.status,
            jo.custom_fecha_fin
        FROM
            `tabJob Offer` jo
        WHERE
            jo.docstatus = 1
    """, as_dict=True)

    # Crear un mapeo DNI -> Empresa
    employee_company_map = {}
    if job_offers:
        job_offers_df = pd.DataFrame(job_offers)

        for dni, group in job_offers_df.groupby('dni'):
            group = group.sort_values(
                by=['status', 'custom_fecha_fin'], 
                ascending=[False, False]  # Alta primero, Baja con fecha más reciente
            )
            selected_row = group.iloc[0]
            employee_company_map[dni] = selected_row['company']

    return employee_company_map

def export_expense_claim_summary():
    # Obtener datos de Expense Claim y sus detalles desde Expense Claim Detail
    expense_claim_details = frappe.db.sql("""
        SELECT
            ec.employee,
            ec_detail.expense_type AS expense_claim_type,
            ec_detail.amount AS total_claimed_amount
        FROM
            `tabExpense Claim Detail` ec_detail
        INNER JOIN
            `tabExpense Claim` ec
        ON
            ec_detail.parent = ec.name
        WHERE
            ec.docstatus = 0
    """, as_dict=True)

    if not expense_claim_details:
        frappe.throw("No se encontraron registros de Expense Claim en borrador.")

    # Asegurar que los datos sean válidos
    if not isinstance(expense_claim_details, list) or not all(isinstance(row, dict) for row in expense_claim_details):
        frappe.throw("Los datos de Expense Claim Detail no tienen el formato esperado.")

    # Limpiar y convertir datos a DataFrame
    clean_data = [row for row in expense_claim_details if row]
    expense_claims_df = pd.DataFrame(clean_data)

    # Obtener datos de los empleados
    employees = frappe.db.get_all(
        'Employee',
        fields=['name as employee', 'employee_name', 'custom_dninie_Id as dni']
    )

    # Convertir datos de empleados a DataFrame
    if not employees:
        frappe.throw("No se encontraron registros de empleados.")
    employees_df = pd.DataFrame(employees)

    # Mapeo DNI -> Empresa desde Job Offer
    employee_company_map = get_company_from_job_offer()
    employees_df['company'] = employees_df['dni'].map(employee_company_map)

    # Validar datos antes de unir
    if employees_df.empty or expense_claims_df.empty:
        frappe.throw("No hay suficientes datos para procesar.")

    # Unir datos de Expense Claim con detalles del empleado
    merged_df = expense_claims_df.merge(employees_df, on='employee', how='left')

    # Agrupar por empleado y tipo de gasto
    grouped_df = merged_df.groupby(['employee', 'employee_name', 'dni', 'company', 'expense_claim_type'], as_index=False).agg({
        'total_claimed_amount': 'sum'
    })

    # Pivotar los datos para que cada tipo de gasto sea una columna
    if grouped_df.empty:
        frappe.throw("No hay datos agrupados para generar el informe.")
    pivot_df = grouped_df.pivot(
        index=['employee', 'employee_name', 'dni', 'company'],
        columns='expense_claim_type',
        values='total_claimed_amount'
    ).reset_index()

    # Reemplazar NaN con 0 en las columnas de gastos
    pivot_df.fillna(0, inplace=True)

    # Crear el archivo Excel
    file_name = "Expense_Claim_Summary.xlsx"
    file_path = frappe.utils.get_site_path("public", "files", file_name)

    try:
        pivot_df.to_excel(file_path, index=False)
    except Exception as e:
        frappe.throw(f"Error al generar el archivo Excel: {str(e)}")

    # Guardar el archivo en el sistema de archivos de Frappe
    save_file(
        file_name,
        open(file_path, 'rb').read(),
        dt=None,
        dn=None,
        is_private=0
    )

    frappe.msgprint(f"Archivo generado correctamente: {file_path}")

# Llamar a la función
export_expense_claim_summary()
2024-11-21 10:44:49,300 INFO ipython import frappe
import pandas as pd
from frappe.utils.file_manager import save_file

def get_company_from_job_offer():
    """
    Mapea el DNI de los empleados con la empresa correspondiente,
    basado en el estado de contratación en Job Offer.
    """
    job_offers = frappe.db.sql("""
        SELECT
            jo.custom_dninie AS dni,
            jo.company,
            jo.status,
            jo.custom_fecha_fin
        FROM
            `tabJob Offer` jo
        WHERE
            jo.docstatus = 1
    """, as_dict=True)

    # Crear un mapeo DNI -> Empresa
    employee_company_map = {}
    if job_offers:
        job_offers_df = pd.DataFrame(job_offers)

        for dni, group in job_offers_df.groupby('dni'):
            group = group.sort_values(
                by=['status', 'custom_fecha_fin'], 
                ascending=[False, False]  # Alta primero, Baja con fecha más reciente
            )
            selected_row = group.iloc[0]
            employee_company_map[dni] = selected_row['company']

    return employee_company_map

def export_expense_claim_summary():
    # Obtener datos de Expense Claim y sus detalles desde Expense Claim Detail
    expense_claim_details = frappe.db.sql("""
        SELECT
            ec.employee,
            ec_detail.expense_type AS expense_claim_type,
            ec_detail.amount AS total_claimed_amount
        FROM
            `tabExpense Claim Detail` ec_detail
        INNER JOIN
            `tabExpense Claim` ec
        ON
            ec_detail.parent = ec.name
        WHERE
            ec.docstatus = 0
    """, as_dict=True)

    if not expense_claim_details:
        print("No se encontraron registros de Expense Claim en borrador.")
        return

    # Validar y limpiar datos
    clean_data = [row for row in expense_claim_details if row]
    if not clean_data:
        print("Los datos de Expense Claim están vacíos o mal formateados.")
        return

    expense_claims_df = pd.DataFrame(clean_data)

    # Obtener datos de los empleados
    employees = frappe.db.get_all(
        'Employee',
        fields=['name as employee', 'employee_name', 'custom_dninie_Id as dni']
    )

    if not employees:
        print("No se encontraron registros de empleados.")
        return

    employees_df = pd.DataFrame(employees)

    # Mapeo DNI -> Empresa desde Job Offer
    employee_company_map = get_company_from_job_offer()
    employees_df['company'] = employees_df['dni'].map(employee_company_map)

    # Validar datos antes de unir
    if employees_df.empty or expense_claims_df.empty:
        print("No hay suficientes datos para procesar.")
        return

    # Unir datos de Expense Claim con detalles del empleado
    merged_df = expense_claims_df.merge(employees_df, on='employee', how='left')

    # Agrupar por empleado y tipo de gasto
    grouped_df = merged_df.groupby(['employee', 'employee_name', 'dni', 'company', 'expense_claim_type'], as_index=False).agg({
        'total_claimed_amount': 'sum'
    })

    # Pivotar los datos para que cada tipo de gasto sea una columna
    if grouped_df.empty:
        print("No hay datos agrupados para generar el informe.")
        return

    pivot_df = grouped_df.pivot(
        index=['employee', 'employee_name', 'dni', 'company'],
        columns='expense_claim_type',
        values='total_claimed_amount'
    ).reset_index()

    # Reemplazar NaN con 0 en las columnas de gastos
    pivot_df.fillna(0, inplace=True)

    # Crear el archivo Excel
    file_name = "Expense_Claim_Summary.xlsx"
    file_path = frappe.utils.get_site_path("public", "files", file_name)

    try:
        pivot_df.to_excel(file_path, index=False)
        print(f"Archivo generado correctamente en: {file_path}")
    except Exception as e:
        print(f"Error al generar el archivo Excel: {str(e)}")

# Ejecutar la función
export_expense_claim_summary()
2024-11-21 10:44:49,301 INFO ipython === session end ===
2024-11-28 12:52:31,962 INFO ipython === bench console session ===
2024-11-28 12:52:31,963 INFO ipython import frappe
from datetime import datetime

# Obtener la fecha actual
today = datetime.now().date()

# Filtrar las transacciones bancarias creadas hoy por el usuario 'Administrator'
bank_transactions = frappe.get_all(
    "Bank Transaction",
    filters={
        "creation": [">=", f"{today} 00:00:00"],
        "creation": ["<=", f"{today} 23:59:59"],
        "owner": "Administrator"
    },
    fields=["name", "creation"]
)

# Eliminar las transacciones encontradas
for transaction in bank_transactions:
    try:
        frappe.delete_doc("Bank Transaction", transaction["name"])
        print(f"Eliminado: {transaction['name']} creado en {transaction['creation']}")
    except Exception as e:
        print(f"Error al eliminar {transaction['name']}: {e}")

# Confirmar los cambios
frappe.db.commit()
print(f"Total eliminados: {len(bank_transactions)}")
2024-11-28 12:52:31,964 INFO ipython import frappe
from datetime import datetime

# Obtener la fecha actual
today = datetime.now().date()

# Filtrar transacciones bancarias creadas hoy
bank_transactions_count = frappe.db.count(
    "Bank Transaction",
    filters={
        "creation": [">=", f"{today} 00:00:00"],
        "creation": ["<=", f"{today} 23:59:59"]
    }
)

print(f"Total de transacciones bancarias creadas hoy: {bank_transactions_count}")
2024-11-28 12:52:31,964 INFO ipython === session end ===
2024-11-28 12:57:43,531 INFO ipython === bench console session ===
2024-11-28 12:57:43,531 INFO ipython import frappe
from datetime import datetime

# Obtener la fecha actual
today = datetime.now().date()

# Filtrar transacciones bancarias creadas hoy
bank_transactions_count = frappe.db.count(
    "Bank Transaction",
    filters={
        "creation": [">=", f"{today} 00:00:00"],
        "creation": ["<=", f"{today} 23:59:59"]
    }
)

print(f"Total de transacciones bancarias creadas hoy: {bank_transactions_count}")
2024-11-28 12:57:43,531 INFO ipython import frappe
from datetime import datetime

# Obtener la fecha actual
today = datetime.now().date()

# Filtrar transacciones bancarias creadas hoy
bank_transactions_count = frappe.db.count(
    "Bank Transaction",
    filters={
        "creation": [">=", f"{today} 00:00:00"], 
    }
)

print(f"Total de transacciones bancarias creadas hoy: {bank_transactions_count}")
2024-11-28 12:57:43,532 INFO ipython import frappe
from datetime import datetime

# Obtener la fecha actual
today = datetime.now().date()

# Filtrar las transacciones bancarias creadas hoy por 'Administrator'
bank_transactions = frappe.get_all(
    "Bank Transaction",
    filters={
        "creation": [">=", f"{today} 00:00:00"]
        "owner": "Administrator"
    },
    fields=["name", "docstatus", "creation"]
)

# Procesar las transacciones encontradas
for transaction in bank_transactions:
    try:
        # Obtener el documento completo
        doc = frappe.get_doc("Bank Transaction", transaction["name"])
        
        # Cancelar si está enviado (Submitted)
        if doc.docstatus == 1:  # Estado enviado
            doc.cancel()
            print(f"Cancelado: {transaction['name']} creado en {transaction['creation']}")

        # Eliminar el documento
        frappe.delete_doc("Bank Transaction", transaction["name"])
        print(f"Eliminado: {transaction['name']} creado en {transaction['creation']}")
        
    except Exception as e:
        print(f"Error al procesar {transaction['name']}: {e}")

# Confirmar los cambios
frappe.db.commit()
print(f"Total procesados: {len(bank_transactions)}")
2024-11-28 12:57:43,532 INFO ipython import frappe
from datetime import datetime

# Obtener la fecha actual
today = datetime.now().date()

# Filtrar las transacciones bancarias creadas hoy por 'Administrator'
bank_transactions = frappe.get_all(
    "Bank Transaction",
    filters={
        "creation": [">=", f"{today} 00:00:00"],
        "owner": "Administrator"
    },
    fields=["name", "docstatus", "creation"]
)

# Procesar las transacciones encontradas
for transaction in bank_transactions:
    try:
        # Obtener el documento completo
        doc = frappe.get_doc("Bank Transaction", transaction["name"])
        
        # Cancelar si está enviado (Submitted)
        if doc.docstatus == 1:  # Estado enviado
            doc.cancel()
            print(f"Cancelado: {transaction['name']} creado en {transaction['creation']}")

        # Eliminar el documento
        frappe.delete_doc("Bank Transaction", transaction["name"])
        print(f"Eliminado: {transaction['name']} creado en {transaction['creation']}")
        
    except Exception as e:
        print(f"Error al procesar {transaction['name']}: {e}")

# Confirmar los cambios
frappe.db.commit()
print(f"Total procesados: {len(bank_transactions)}")
2024-11-28 12:57:43,532 INFO ipython === session end ===
